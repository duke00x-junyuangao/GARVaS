
#' Generate the 1st generation of the genetic algorithm
#'
#' Bernoulli sampling to form the first generation of the algorithm.
#' Since interactions are possible, 2*C is a valid population size but
#' imposing an upper limit of 50 doesn't hurt.
#'
#' @param C Chromosome length (number of predictors)
#' @return Matrix, [C x 2C] or [C x 50], with each column representing a chromosome.
init <- function(C){
  P <- min(2*C, 50)
  replicate(P, sample(c(0,1), size=C, replace=T))
}

#' Select variables using the genetic algorithm
#'
#' Selecting parents based on fitness ranks, with AIC as the default fitness criteria.
#' Alternatively, we can use tournament selection.
#'
#' @param pop Population matrix, such as the parent generated using init().
#' @param f Fitness function that takes in an lm or glm model and returns a
#' a numerical 'qualification' of that model. Defaults to AIC.
#' @param dat Data frame with columns as predictors.
#' First column should be the response variable.
#' @return list
selection <- function(pop, f=AIC, dat){

  # number of individuals
  P <- ncol(pop)

  # Store the fitness
  fit <- rep(1, P)

  # Variables are columns of the dataset
  cols <- colnames(dat)

  for (i in 1:P){

    # Find the chosen predictors and use them as index
    chosen <- which(pop[,i]==1) + 1

    # Build a formula using the chosen predictors
    form <- as.formula(paste(cols[1], "~", paste(cols[chosen], collapse = "+")))

    # Built the linear model
    mod <- lm(form, data=dat)

    # Calculate the fitness using the provided fitness function
    # Lowest AIC has the highest rank so take the negative
    fit[i] = -f(mod)
  }

  # Compute a vector of probability weights
  fitness <- 2*rank(fit)/(P*(P+1))

  # Sample from the P individuals, with weights specified as in fitness,
  # with replacement, to generate a parenting population of size P.
  # Note there are duplicates within the parenting population.
  parent_ind <- sample(x=1:P, size=P, replace=T, prob=fitness)
  parents <- pop[ ,parent_ind]

  # Keep a copy of the fittest individual.
  fittest <- pop[,which(fitness==max(fitness))]

  # Return the results as a list
  list(parents, fittest, -fit)
}

mutation = function(ind){#Use fixed rate 0.01
  n = length(ind)
  for (i in 1:n){
    a = sample(1:100, size=1)
    if (a==1){ind[i] = 1 - ind[i]}
    #If mutation happens at one locale, change the 1 at that postition to 0(or 0 to 1).
    else{next}
  }
  return(ind)
}

crossover = function(ind1, ind2){ #Simply one-point crossover.
  C = length(ind1) #Length of chromosome
  k = sample(1:(C-1), 1) #randomly select a point as the point of crossover.
  ind1_new = mutation(c(ind1[1:k], ind2[(k+1):C]))
  ind2_new = mutation(c(ind2[1:k], ind1[(k+1):C]))
  return(matrix(c(ind1_new, ind2_new), ncol=2))
}


produce = function(pop){#pop is generated using selection()
  #Production from generation t to generation (t+1).
  P = ncol(pop)
  order = sample(1:P, size=P)#Randomly assign paris
  newGen = crossover(pop[,order[1]], pop[,order[2]]) #The first two offspring generated by the first pair of parents.
  for (i in 2:(P/2)){
    newGen = cbind(newGen, crossover(pop[,order[2*i-1]], pop[,order[2*i]]))
  }
  return(newGen)
}


update = function(dat, generations=10, f=AIC, graph=TRUE){#Control maximum generation
  C = ncol(dat) - 1 ##minus y
  pop = init(C)
  fit.val=matrix(0,min(2*C, 50),generations)
  generation.mat=matrix(rep(1:generations,each=min(2*C),50),min((2*C),50),generations)
  for (i in 1:generations){

    sel.result=selection(pop,f, dat)
    parents = sel.result[[1]]
    fit.val[,i]=sel.result[[3]]
    pop = produce(parents)
  }
  if (graph){
     matplot(generation.mat,fit.val,type="p",pch=4,col=1,xlab="Generation",ylab="Fitted Value")}

  fittest = selection(pop,f,dat)[[2]]
  chosen = c(which(fittest[,1] == 1))
  mod = lm(as.formula(paste(colnames(dat)[1], "~", paste(colnames(dat)[chosen+1], collapse = "+"),
                                sep = "")), data=dat)
  return(list(pop, fittest, fit.val, mod))

  #Return four things: a matrix of the last generation; a listing of the fittest individual(s);
  #The AIC score of the last generation; and a lm() model using the chosen variables.
  #After 10 generations, the fittest ones are mostly the same, which shows convergence.
}

